package ango

import (
	"errors"
)

// LinkedObject should be embedded
type LinkedObject struct {
	prov *Provider

	// maps connID to linked object id (generated by client)
	links map[uint64]uint64
}

// setupLinks makes the links map
func (lo LinkedObject) setupLinks() {
	if lo.links == nil {
		lo.links = make(map[uint64]uint64)
	}
}

// provider returns the provider for this linkedobject
func (lo LinkedObject) provider() *Provider {
	return lo.prov
}

func (lo LinkedObject) setProvider(p *Provider) {
	lo.prov = p
}

// Returns whether this LinkedObject is linked with given connection ID, and if so the link id
func (lo LinkedObject) link(connID uint64) (uint64, bool) {
	lo.setupLinks()
	id, ok := lo.links[connID]
	return id, ok
}

func (lo LinkedObject) setLink(connID uint64, linkID uint64) {
	lo.setupLinks()
	lo.links[connID] = linkID
}

// makes any type embedding LinkedObject implement this interface
type loIface interface {
	provider() *Provider
	setProvider(*Provider)
	link(uint64) (uint64, bool)
	setLink(uint64, uint64)
}

// eats a linked object and returns a link.
// when not a linked object, returns given object without change
func (c *Conn) tryLinkedObject(data interface{}) (*uint64, error) {
	lo, ok := data.(loIface)
	if !ok {
		return nil, nil
	}

	// check if provider matches for this linked object
	// it must match because the connID is a reference to that provider
	//++ TODO: make connID ango-wide unique and ditch provider for linked objects?
	if c.provider != lo.provider() {
		if lo.provider() == nil {
			lo.setProvider(c.provider)
		} else {
			return nil, errors.New("linked object was registered with a different provider")
		}
	}

	// check if linkedobject is linked with this connection already
	id, ok := lo.link(c.connID)
	if !ok {
		var err error
		id, err = c.registerLinkedObject(data)
		if err != nil {
			return nil, err
		}
	}

	// return link
	return &id, nil
}

// registerLinkedObject registers a linked object.
func (c *Conn) registerLinkedObject(data interface{}) (uint64, error) {
	// new callback chan
	cbid, cbch := c.newCallbackChan()

	// send message with type lor and callback id set
	err := c.sendMessage(&messageOut{
		Type:       "lor",
		Data:       data,
		CallbackID: &cbid,
	})
	if err != nil {
		return 0, err
	}

	cb := <-cbch

	return cb.newID, nil
}
